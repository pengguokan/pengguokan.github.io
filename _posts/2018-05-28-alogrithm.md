---
layout: post
title: 【工作随记】从乱序数组中找一个最接近且不小于指定数的元素
categories: [算法, 工作]
description: 记工作中的
keywords: 数组, 算法
---

前段时间在开发一个需求，遇到了一个有意思的问题，抽象描述下：输入一个数字Y，在一个数组
```
u = {X0, X1, ... Xn}
```
中，找出离X最近，且不小于Y的元素。

首先想到的是对数组u排序，然后从头遍历一遍，直到找出满足条件的元素。时间复杂度来说，最快应该是：
```
O(NlogN)+O(N)
```

再细想一下，为了找一个数字，排序一遍，是不是没有必要？查找符合条件的数字，无非就是对比+交换，上述的方法本质上是进行了两轮对比交换（排序、遍历）。


对数组u进行处理下：每个元素都减去Y，得到数组u'：
```
u' = {X0 - Y, X1 - Y, ..., Xn - Y} = {X0', X1', ..., Xn'}
```
这样，u'的元素，要么是
>0：比Y大
=0：和Y相等
<0：比Y小

对u'进行一轮遍历，通过类似对比排序的方式，就可以找出最小且≥0的x'了，从而找到了x。
```java
int y;//输入y
int index = 0;
int tmp = (u[index] - y);
for(int i = 1; i < u.size(); i++){
    if(tmp <= (u[i] - y) && tmp >= 0){
        tmp = (u[i] - y);
        index = i;
    }
}
int result = u[index]
```
时间复杂度只需要O(N)，小于O(NlogN)。